a,b,c=map(int,input().split())
e=a+b
if a==0:print(0)
elif a==c:print(1)
elif (a%2 and c%2==0)or e<=c:print(-1)
else:
    t=int((a-0.1)//c)+1
    q=(c-a)%c
    while(1):
        if q%2:t+=1;q+=c
        z=q//2
        r=(z-0.1)//e
        x=z%e
        p=1
        if b>=x:p=0
        if t>=(r+1)*2+p:break
        else:t+=1;q+=c
    print(t)

## 설명을 위해 뒤집어야할 물건을 동전이라고 칭한다.

## A가 0이라면, 이미 전부 뒷면인  상태이므로 0을 출력.
## A랑 C랑 같다면, 한번만에 전부 뒷면으로 만들  수 있으므로 1을 출력.
## A가 홀수이고, C가 짝수라면 몇번을 뒤집어도 전부 뒤집을 수 없으므로 -1을 출력
## 동전의 합보다 뒤집어야 하는 개수의 동전이 많다면, 뒤집을 수 없으므로 -1을 출력

## 예외처리 이외
## 변수 t에는  int((a-0.1)//c)+1 의 값을 저장한다.
## 변수 q에는  q=(c-a)%c의 값을 저장한다.
## 이 시점에서 t,q의 값은
## a를 전부 뒤집으려고 뒤집기를 실행했을때의
## t(실행해야 하는 회수) + q(이번턴에 더 뒤집어야할 나머지)이다.

## ex)
## 8 0 3 이라면, t==3, q==1 일 것이다.
## 8을 전부 뒤집으려면 3턴이 필요하고, 1개를 더 뒤집어야 한다.

## While문 안쪽,
## if q%2:t+=1;q+=c  // q가 홀수라면, t에는 1을, q에는 c만큼을 더해준다.
## 한국어로 해설하자면
## while문 안쪽에서는, t만큼 턴을 사용하여 모두 뒤집었을때, q만큼을 더 뒤집어야 한다는 뜻의 변수 t,q를 가지고 있다.
## 여기서 q가 홀수라면, 동전이 모두 뒷면인 상태에서  q만큼 다시 뒤집으면 앞면인 동전이 생기므로, 1회 더 C만큼 뒤집기를 실행한다.
## q만큼 다시 뒤집어야 하는 상태에서, 1턴 더 사용하므로 c+q만큼 뒤집어야한다.

## z=q//2
## q는 뒤집어야할 횟수이다.
## 현재 우리의 동전은 모두 뒷면이기 때문에, 동전을 2의 배수의 횟수로 뒤집어야한다.
## 따라서 동전을 6번 뒤집어야 한다면, 동전을 3번 선택하여 두번씩 뒤집어야한다,
## z는, q번 동전을 뒤집어야할때, 선택해야할 동전의 횟수이다.

## r=(z-0.1)//e
## z는 선택해야할 동전의 횟수, e는 동전의 총 개수이다.
## r+1은 턴을 몇번 실행해야, z만큼 동전을 선택할 수 있는지를 말한다.
## x=z%e
## x는 턴을 실행했을때, 남는 동전의 개수를 뜻한다.


## r이랑 x는, 크게보면 t,q와 같다.

## p=1
## if b>=x:p=0
## 시작때 앞면이었던 동전은 기본적으로 1번 선택을 한다.
## 아래에서 while문을 빠져나가는 조건이
## 총 실행한 턴 >= 뒤집어야할 회수가 가장 많은 동전이므로,
## 만약, 시작때 앞면이었던 동전을 다시 뒤집어야한다면
## 시작때 뒷면이었던 동전을 다시 뒤집는 행동 + 1 턴이 더 필요하다.
## 이것을 판별할때 쓰는 변수가 p 이다.
    
##    if t>=(r+1)*2+p:break
##        else:t+=1;q+=c
## 이것을 바탕으로, 조건이 맞을때까지 돌려서 while문을 빠져나간다.
## 그리고 t를 출력하면 된다.





## 그림으로 그리면 이런 느낌이다.
## 앞면이 1개, 뒷면인 7개인 동전을 
## 턴마다 7개씩 뒤집어서 전부 뒷면으로 만들어야 한다면.

## 앞뒤뒤뒤 뒤뒤뒤뒤
## 홀짝짝짝 짝짝짝짝   - 회수로 뒤집어야 한다.
    
## 1턴만에, 앞면인 동전을 전부 뒤로 만들고 6회 행동이 남는다.
## 뒤뒤뒤뒤 뒤뒤뒤뒤
## (1000 0000) - 1턴 뒤집기를 실행, 6회 더 남음.
## (1222 0000) - 1턴 뒤집기를 실행, 0회 더 남음.
## 하지만 1턴동안 2번 뒤집는 동전이 존재할 수 없기 때문에, 7번을 더 실행
## 뒤뒤뒤뒤 뒤뒤뒤뒤 상태에서 13번 뒤집기를 실행해서는, 앞면이 생기기 때문에
## 1턴 더 사용하여 7회 뒤집기를 추가한다.
## (1000 0000) - 3턴 뒤집기를 실행, 20회 더 남음.
## (3442 2222) - 3턴 뒤집기를 실행, 0회 더 남음.
## 하지만 3턴동안 4번 뒤집는 동전이 존재할 수 없기 때문에 7번을 더 실행
## 뒤뒤뒤뒤 뒤뒤뒤뒤 상태에서 27번 뒤집기를 실행해서는 앞면이 생기기 때문에,
## 1턴 더 사용하여 7회 뒤집기를 추가한다.
## (1000 0000) - 5턴 뒤집기를 실행, 34회 더 남음.
## (5444 4446) - 5턴 뒤집기를 실행. 0회 더 남음.
## 마찬가지로 불가능하므로 위의 알고리즘에 따라 2회 더 추가
## (1000 0000) - 7턴 뒤집기를 실행. 48회 더 남음
## (7666 6666) - 7턴 뒤집기를 실행. 0회 더 남음.
## 7턴동안 동전을 최대 7번 뒤집는 것은 가능한 알고리즘이므로,
## while문을 빠져나오고 7을 출력한다.
    
