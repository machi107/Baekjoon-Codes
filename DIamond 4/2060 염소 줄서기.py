a=input()
b=input()
c=int(input())


# a와 b와 c를 입력받는다.
# 우리가 구해야 할 것은
# a와 b사이에 존재하는 모든 숫자중에 0과 1로만 이루어진 숫자를
# 문제에 나온 순서대로 정렬했을때 C번째에 존재하는 숫자가 무엇인지를 구해야한다.


lena=len(a)
lenb=len(b)
onea=a.count("1")
oneb=b.count("1")


###
##  이진수이기 때문에,
##  또한 0 번이 아닌 염소를 제외하고는 맨 앞자리를 0으로 가질 수 없으므로
##  1000과 1111로 나타낼 수 있는 염소의 최대 수는 8마리이다.
##  ex (1000 1001 1010 1011 1100 1101 1110 1111)
##  또한, 이 8마리를 문제에 나온 순서대로 정렬하면
##  ex (1000 / 1001 1010 1100 / 1011 1101 1110 / 1111) 으로 정렬할 수 있다.
##  앞에서부터 1이 하나인 번호, 1이 두개인 번호, 3개인 번호, 4개인 번호.
##
##  이러한 규칙에 따라 정렬하면 이진수의 길이가 5(10000~ 11111)인 번호들로는
##  16마리의 염소를 정렬할 수 있으며,
##  이때, 16개는 X = [0,1,4,6,4,1]로 나타낼 수 있다.
##  이 X[i]에 위치한 숫자는 1이 i만큼 있는 숫자의 개수를 나타낸다.
##
##  x[0]이 0을 제외하고는 무조건 0이기 때문에, 시작이 1이 아니라
##  0 1 로 시작하는 파스칼의 삼각형의 변형이라고 생각하고 문제를 풀면 될 것 같다.
##       0 1
##      0 1 1
##     0 1 2 1
##    0 1 3 3 1
##   0 1 4 6 4 1
##  0 1 5 10 10 5 1....
##
##  따라서 len(a),len(b)를 안다면, 대략적으로 구해야할 번호의 양을 알 수 있다.
##  또한 onea oneb는 나중에 써야할 변수이니 일단 같이 구해둔다.
###



s=[[0 for _ in range(32)] for _ in range(32)]
s[0][0]=1
for i in range(32):
    for j in range(32-i):
        if i!=0 and j!=0:s[i][j]=s[i-1][j]+s[i][j-1]
        elif i!=0: s[i][j]=s[i-1][j]
        elif j!=0: s[i][j]=s[i][j-1]

###
##        번호의 길이는 최대 31비트이므로,
##        31까지 파스칼의 삼각형을 만들어준다.
##        파스칼의 삼각형은 만들기 어려우므로
##        나는 파스칼의 삼각형을 45도 기울인
##        파스칼의 정사각형을 만들어서 s라는 2차원 배열에 저장했다.
###


        
xxxxx=[0 for i in range(lenb-1)]


for h in range(lena,lenb):
    for i in range(h):
        xxxxx[i]+=(s[i][h-i-1])


#
##    xxxxx 라는 배열을 만들어서, 0으로 lenb의 길이-1 만큼 만들어준다.
##    왜 lenb-1로 만들어주냐 하면,
##
##    A와 B 사이에 있는 모든 숫자를 구하기 위해서는
##    A가 1010 , B가 101001라고 가정하자.
##
##    방법 1
##    1000~111111 까지의 모든 가능한 숫자를 구한다.
##    1000~1010사이의 값과, 101001~111111사이의 값을 빼준다.
##    방법 2
##    1000~11111 까지의 모든 가능한 숫자를 구한다.
##    1000~1010 사이의 값을 빼주고
##    100000 ~ 101001 까지의 값을 더해준다.
##    방법 3
##    10000~111111 까지의 모든 가능한 숫자를 구한다.
##    1010~10000 사의 값을 더해주고,
##    101001~ 111111 사이의 값을 빼준다.
##
##    여기서 방법1 보다는 방법 2나 3이,
##    똑같은 연산을 두번 사용하여 코드가 직관적이기 때문에,
##    
##    일단 나같은 경우에는
##    방법 2를 사용하였다.
##
##    즉 현재 여기서 xxxxx라는 배열은
##    lena에서부터 lenb-1의 값까지,
##    A가 세자리수고 B가 다섯자리 수면,
##    100~ 1111 까지의 모든 값을 더해준 배열의 값이라고 보면 된다.
##
##    1 2 1
##    1 3 3 1을 더한
##    2 5 4 1 을 가지고 있게 된다.
##
##    A와 B가 len 차이가 1 미만일 때는
##    len(b)-1만큼 0으로 채워져있다.
##
##    따라서, 다시한번 정리하자면
##    이 시점에서 xxxxx의 값은
##    len(a)로 만들어 낼수 있는 이진수의 수 ~ len(b)-1로 만들어 낼수 있는 이진수의 수의 최댓값까지 저장되어있다.


if a=='0':
    xxxxx.insert(0,1)
else:
    xxxxx.insert(0,0)
xxxxx.append(0)

### a가 0일 때와 1일때를 구별하기 위해, xxxxx[0]에 1이나 0을 투입한다.
### xxxxx[0]의 값은, 염소의 번호에 1이 존재하지 않는다는 뜻이다.
### 따라서 A가 0일때만 존재할 수 있으므로, a로 판별한다.
### xxxxx 뒤에 0을 추가하는 이유는, len(b)의 이진수를 판별할때, indexError을 방지하기 위해서이다.





r=[]
for k in range(lena):
    r.append(s[k][lena-k-1])

## r은 lena에서 만들 수 있는 이진수의 개수
## 1000이면, [1,3,3,1]을 가진다.
## 이는, 각각, 1을 1개, 2개, 3개, 4개 가진다는 것을 뜻한다.

rr=[]
for i in range(1,lena):
    rrr=[]
    if a[i]=="1":
        for _ in range(len(rr)):
            rrr.append(0)
        for h in range(lena-i):
            rrr.append(s[h][lena-i-h-1])
        rr.append(rrr)
        
## rrr은, a의 각 자리수를 비교하면서, a[i]==1이었을때,
## 그것보다 작은 숫자로 만들 수 있는 이진수의 개수이다.
## 그것을 전부 저장한게 rr이다.
## 예를들어, a가 1110이라면,
## a의 백의자리수가 1이므로, 백의 자리수가 0인 숫자들은 전부, 그것보다 낮을 것이다.
## 십의자리수....
## 그런식으로 계산한다면, rr에 [[1,2,1],[0,1,1]]이 들어오게 된다. (백의자리수, 십의자리수)


for i in range(len(rr)):
    for j in range(len(rr[i])):
        xxxxx[j+1]-=rr[i][j]

## xxxxx에, rr을 빼준다.
## 이것으로 우리는, A보다 크고, len(b)-1의 이진수의 최댓값보다 작은 모든 경우의 수를 구했다.

r=[]
for k in range(lenb):
    r.append(s[k][lenb-k-1])
rtr=[]
for i in range(1,lenb):
    rrr=[]
    if b[i]=="1":
        for _ in range(len(rtr)):
            rrr.append(0)
        for h in range(lenb-i):
            rrr.append(s[h][lenb-i-h-1])
        rtr.append(rrr)
for i in range(len(rtr)):
    for j in range(len(rtr[i])):
        xxxxx[j+1]+=rtr[i][j]


## 똑같은 연산으로 해서, len(b)중에서 b보다 작은 숫자로 만들수 있는 이진수의 개수를 구한뒤에
## xxxxx에, rtr을 더해준다.
## 이것으로 우리는, A보다 크거나 같고   b보다 작은 모든 경우의 수를 구했다.


xxxxx[oneb]+=1

## b랑 같은 경우도 포함해야하므로, 하나를 더해준다.

for i in range(len(xxxxx)):
    if c>xxxxx[i]:c-=xxxxx[i]
    else:break
ionec=i

## 모든 경우의 수의 합을, 앞에서부터 탐색하면서, C보다 커질때 break한다.
## 그 변수를 ionec에 저장한다. ionec는, A~B 사이의 번호중 C번째 번호는, 1을 ionec만큼 가지고 있다는 것을 뜻한다.



for i in range(len(rr)):
    if len(rr[i])>(ionec-1):
        c+=rr[i][ionec-1]
## 위에서 남은 c에, 아까 처리해줫던 rr값을 더해준다.
## 우리는 1을 ionec만큼 가진 숫자를 구할 것인데,
## A가 1010인경우, 1을 두개가진 네자리 숫자중 두번째로 작은 것은 (1001이 없어지기때문에) 1100이다.
## 그 예외처리를 위해 더해준다.



for i in range(lena-1,lenb+1):
    q=1
    for j in range(ionec-1):
        q*=(i-j)/(j+1)
    if c>q:c-=q;
    else:break
anslen=i+1

## 이쯤에서 한번 변수를 정리해보자.
## a는 염소의 번호 중 최솟값
## b는 염소의 번호 중 최댓값
## 우리가 구해야할것은 a~b의 염소를 줄세웠을때 t에 위치해있는 염소
## 그 정답의 염소는 ionec 만큼 1을 가진 숫자이고, 그 중 c번째로 작은 값이다.


## 정답의 염소가 1을 ionec만큼 가진것은 구했지만,
## 정답인 염소의 숫자의 길이가 얼마나 되는지는 아직 구해지 못했으므로,
## 그걸 구하기 위해 조합을 구한다.
## ex) 길이가 8인 이진수에서, 1을 3개만큼 가진 값은 총 7c2의 값을 가진다. (맨 앞의 1은 고정이므로)
## 따라서 길이가 len(a)보다 크고, len(b)보다 작은 값들을 순서대로 비교하면서 c에서 계속 빼주다가, 커지면 break.

## 따라서 anslen은, 말그대로 정답의 숫자 길이가 anslen 이라는 뜻이다.
## 길이가 anslen이면서, 1을 ionec만큼 가진 숫자들을 정렬했을때, c번째 숫자가 정답이다.



if ionec==0:
    print(0)

## 1을 하나도 가지지 않은 숫자가 정답인 경우,
## 0밖에 존재하지 않으므로, 예외처리로 빼준다.

else:
    ansans=[]
    ansans.append(1)
    for i in range(anslen-ionec):
        ansans.append(0)
    for j in range(ionec-1):
        ansans.append(1)
    for i in range(1,int(c)):
        for j in range(1,anslen):
            if ansans[-j]==1 and ansans[-j-1]==0:
                ansans[-j],ansans[-j-1]=0,1
                ansans = ansans[:-j] + sorted(ansans[-j:])
                break;

## ansans라는 리스트를 만든다.
## 맨 앞의 숫자는 1이 고정이므로, 가장 먼저 1만큼 추가한다.
## ionec값 (1을 가진 값을 뺀만큼) ansans에 0을 추가한다.
## 반대로 ionec값-1(맨앞의 1) 만큼 ansans에 1을 추가한다.
## 예를들어서, 정답의 길이가 7이면서, 1을 세개 가진 값이라고 하면, ansans는 처음에 1000011 값으로 시작한다. (조건을 만족하는 값중 최소값)
## c값만큼 반복하면서, 가장 오른쪽 비트를 왼쪽으로 미는 연산을 한다.( 불가능하다면 그 다음 비트를 밀고 하위비트를 오른쪽 정렬)


    q=""
    for i in range(anslen):
        q+=str(ansans[i])
    print(q)

## 그러면 정답 이진수가 [1,0,0,0,1,0,1,0,0] 식의 꼴로 anslen 리스트에 저장되고,
## 앞에서부터 추가하면서 문자열에 저장해둔 후에 출력하면 된다.
